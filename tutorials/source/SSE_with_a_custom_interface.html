<div class="w3-row-padding w3-padding-64 w3-container">
  <div class="w3-content">
    <div class="">
      <h1>Server-sent events with a custom interface</h1>
        <p> In this tutorial we will add a server-sent event (SSE) stream to our HelloWorld interface which will stream
            the results of HelloWorld actions to the frontend which will display them in another table. SSE streams allow
            your interface to be highly reative and event-driven. Walkoff has provided objects which makes it much easier
            to construct these streams.</p>
        <h4>1. Create the stream object</h4>
        <p> We'll use the <code>InterfaceSseStream</code>. This object is an event-driven wrapper around Walkoff's
            key-value cache database. It takes two arguments in its constructor, the name of the interface and the name
            of the stream. If you have multiple streams in your interface, the name of the streams must be unique.
            These streams are then attached to the interface's blueprint.
        </p>
        <pre><code class="python">
from interfaces import dispatcher, AppBlueprint
from walkoff.events import WalkoffEvent
from datetime import datetime
from walkoff.sse import InterfaceSseStream

action_result_stream = InterfaceSseStream('HelloWorld', 'action_results')


blueprint = AppBlueprint('HelloWorldPage', __name__, streams=[action_result_stream])
        </code></pre>
        <h4>2. Register callbacks which push events</h4>
        <p> We'll combine the interface event dispatcher with the stream to use the <code>InterfaceSseStream</code>.
            We'll register a couple of callbacks on the interface event dispatcher for the ActionExecutionSuccess and the
            ActionExecutionError events for all actions for the HelloWorld app. We'll register those same callbacks to
            our SSE stream, and we'll make the ActionExecutionSuccess push an "action_success" event to the stream and
            the ActionExecutionError push an "action_error" event to the stream. The callback only needs to return the
            data that the event should carry, and if you want to return JSON data, then there is no need to convert it
            into a string, the stream will handle that for you.
        </p>
        <pre><code class="python">
from interfaces import dispatcher, AppBlueprint
from walkoff.events import WalkoffEvent
from datetime import datetime
from walkoff.sse import InterfaceSseStream

action_result_stream = InterfaceSseStream('HelloWorld', 'action_results')


blueprint = AppBlueprint('HelloWorldPage', __name__, streams=[action_result_stream])


@dispatcher.on_app_actions('HelloWorld', events=WalkoffEvent.ActionExecutionSuccess)
@action_result_stream.push('action_success')
def action_ended_callback(data):
    data['timestamp'] = str(datetime.utcnow())
    return data


@dispatcher.on_app_actions('HelloWorld', events=WalkoffEvent.ActionExecutionError)
@action_result_stream.push('action_failure')
def __action_error_callback(data):
    data['timestamp'] = str(datetime.utcnow())
    return data
        </code></pre>
        <p> Both of these callbacks simply attach a timestamp to the data from the event and push it onto the stream. </p>

        <h4>3. Construct the stream endpoint.</h4>
        <p> Now that we have the stream created, we will create an endpoint to start the SSE connection.</p>
        <pre><code class="python">
@blueprint.route('/actionstream', methods=['GET'])
def stream_workflow_action_events():
    return action_result_stream.stream()
        </code></pre>

        <h4>4. Secure the endpoint</h4>
        <p> SSE connections cannot accept Authorization headers. Instead, we will pass our JWT token in through a query
            parameter. In the <code>server.security</code> module, we have a decorator which checks for this query
            parameter.</p>
        <pre><code class="python">
from flask import Response
from server.security import jwt_required_in_query

@blueprint.route('/actionstream', methods=['GET'])
@jwt_required_in_query
def stream_workflow_action_events():
    return action_result_stream.stream()
        </code></pre>

        <h4>5. Use the endpoint in an interface</h4>
        <p>
            Now that we have an endpoint created, it's time to use it in our interface to display the real-time data.
            In our index.html body, append the following HTML:
        </p>
        <pre><code class="html">
&lth1&gtAction Results&lt/h1&gt
&lttable id="actionResults"&gt
    &ltthead&gt
        &lttr&gt
            &lttd&gtAction UID&lt/td&gt
            &lttd&gtAction Name&lt/td&gt
            &lttd&gtTimestamp&lt/td&gt
            &lttd&gtStatus&lt/td&gt
        &lt/tr&gt
    &lt/thead&gt
    &lttbody&gt&lt/tbody&gt
&lt/table&gt
        </code></pre>
        
        <p>
            This creates a simple table for us to put the action results once we receive them. Note the tbody is empty.
            In our main.js, the following JavaScript code will initiate the SSE event handling to add new rows to our table.
            This should be placed below the other JS code but before the end of the module.
        </p>

        <pre><code class="javascript js">
const eventSource = new EventSource('interfaces/HelloWorld/actionstream?access_token=' + sessionStorage.getItem('access_token'));

function eventHandler(message) {
    let result = JSON.parse(message.data);
    
    $('#actionResults tbody').append(`
        &lttr&gt
            &lttd&gt${result.sender_uid}&lt/td&gt
            &lttd&gt${result.sender_name}&lt/td&gt
            &lttd&gt${result.timestamp}&lt/td&gt
            &lttd&gt${result.data.status}&lt/td&gt
        &lt/tr&gt
    `);
}

eventSource.addEventListener('action_success', eventHandler);
eventSource.addEventListener('action_error', eventHandler);
eventSource.addEventListener('error', (err) => {
    console.error(err);
});
        </code></pre>

        <p>
            We see here that we have an event handler function that is bound to both action success and error events,
            meaning that they are processed the same. Using the SSE you can produce many different types of events
            and potentially process them in different manners. This code will simply push a new row onto the actionResults
            table which contains some of the information from the action result received from the SSE.
        </p>
    </div>
  </div>
</div>

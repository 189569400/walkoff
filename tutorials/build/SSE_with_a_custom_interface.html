<!DOCTYPE html>
<html>
<title>WALKOFF-Automation for All</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/androidstudio.min.css">
<style>

body,h1,h2,h3,h4,h5,h6 {font-family: "Lato", sans-serif}
.w3-navbar,h1,button {font-family: "Montserrat", sans-serif}
.fa-graduation-cap,.fa-flask{font-size:200px}

#headerDiv{
    background-image:url("../../files/images/headerBackground2.png");
    background-size: 50% auto;
    background-repeat: no-repeat;
    background-position:50% 50%;
}

.imageList {
  list-style-type: none;
}

.topLevelList + h5{
  display:none;
}

.fa-circle, .fa-circle-o{
  font-size:12px;
  padding-right:10px;
}

.code{
    background-color:#edf0f4;
    padding:25px;
}


td{
    padding-right:10px;
    margin-bottom: 25px;
    margin-top:25px;
}

.image{
    text-align:center;
}

.image img{
    max-width:100%;
    max-height:100%;
}

.functionality_list li{
    margin-bottom:20px;
}

.tag{
    background-color:#edf0f4;
    text-align:center;
}

img.media-object.image{
    width:100%;
}

.tutorialTable td{
    border-bottom:1px solid black;
}

</style>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    
<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-blue-grey w3-card-2 w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-hide-medium w3-hide-large w3-opennav w3-right w3-padding-large w3-hover-white w3-large w3-red" href="javascript:void(0);" onclick="myFunction()" title="Toggle Navigation Menu"><i class="fa fa-bars"></i></a>
    <a href="../../index.html" class="w3-bar-item w3-button w3-padding-large w3-white">Home</a>
    <a href="../../documentation/build/index.html" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white">Documentation</a>
    <a href="https://github.com/iadgov/WALKOFF" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white">Source</a>
    <a href="../../swagger/index.html" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white">API</a>
    <a href="index.html" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white">Tutorials</a>
  </div>

  <!-- Navbar on small screens -->
  <div id="navDemo" class="w3-navblock w3-white w3-hide w3-hide-large w3-hide-medium w3-large">
    <a class="w3-padding-large" href="../../documentation/build/index.html">Documentation</a>
    <a class="w3-padding-large" href="https://github.com/iadgov/WALKOFF">Source</a>
    <a class="w3-padding-large" href="../../swagger/index.html">API</a>
    <a class="w3-padding-large" href="index.html">Tutorials</a>
  </div>
</div>

<!-- Header -->
<header id="headerDiv" class="w3-container w3-black w3-center w3-padding-64">
  <h1 class="headerText w3-margin w3-jumbo">WALKOFF</h1>
  <h5 class="headerText w3-margin w3-xxxlarge">Tutorials</h5>
</header>

<div class="w3-row-padding w3-padding-64 w3-container">
  <div class="w3-content">
    <div class="">
      <h1>Server-sent events with a custom interface</h1>
        <p> In this tutorial we will add a server-sent event (SSE) stream to our HelloWorld interface which will stream
            the results of HelloWorld actions to the frontend which will display them in another table. SSE streams allow
            your interface to be highly reative and event-driven. Walkoff has provided objects which makes it much easier
            to construct these streams.</p>
        <h4>1. Create the stream object</h4>
        <p> We'll use the <code>InterfaceSseStream</code>. This object is an event-driven wrapper around Walkoff's
            key-value cache database. It takes two arguments in its constructor, the name of the interface and the name
            of the stream. If you have multiple streams in your interface, the name of the streams must be unique.
            These streams are then attached to the interface's blueprint.
        </p>
        <pre><code class="python">
from interfaces import dispatcher, AppBlueprint
from walkoff.events import WalkoffEvent
from datetime import datetime
from walkoff.sse import InterfaceSseStream

action_result_stream = InterfaceSseStream('HelloWorld', 'action_results')


blueprint = AppBlueprint('HelloWorldPage', __name__, streams=[action_result_stream])
        </code></pre>
        <h4>2. Register callbacks which push events</h4>
        <p> We'll combine the interface event dispatcher with the stream to use the <code>InterfaceSseStream</code>.
            We'll register a couple of callbacks on the interface event dispatcher for the ActionExecutionSuccess and the
            ActionExecutionError events for all actions for the HelloWorld app. We'll register those same callbacks to
            our SSE stream, and we'll make the ActionExecutionSuccess push an "action_success" event to the stream and
            the ActionExecutionError push an "action_error" event to the stream. The callback only needs to return the
            data that the event should carry, and if you want to return JSON data, then there is no need to convert it
            into a string, the stream will handle that for you.
        </p>
        <pre><code class="python">
from interfaces import dispatcher, AppBlueprint
from walkoff.events import WalkoffEvent
from datetime import datetime
from walkoff.sse import InterfaceSseStream

action_result_stream = InterfaceSseStream('HelloWorld', 'action_results')


blueprint = AppBlueprint('HelloWorldPage', __name__, streams=[action_result_stream])


@dispatcher.on_app_actions('HelloWorld', events=WalkoffEvent.ActionExecutionSuccess)
@action_result_stream.push('action_success')
def action_ended_callback(data):
    data['timestamp'] = str(datetime.utcnow())
    return data


@dispatcher.on_app_actions('HelloWorld', events=WalkoffEvent.ActionExecutionError)
@action_result_stream.push('action_failure')
def __action_error_callback(data):
    data['timestamp'] = str(datetime.utcnow())
    return data
        </code></pre>
        <p> Both of these callbacks simply attach a timestamp to the data from the event and push it onto the stream. </p>

        <h4>3. Construct the stream endpoint.</h4>
        <p> Now that we have the stream created, we will create an endpoint to start the SSE connection.</p>
        <pre><code class="python">
@blueprint.route('/actionstream', methods=['GET'])
def stream_workflow_action_events():
    return action_result_stream.stream()
        </code></pre>

        <h4>4. Secure the endpoint</h4>
        <p> SSE connections cannot accept Authorization headers. Instead, we will pass our JWT token in through a query
            parameter. In the <code>server.security</code> module, we have a decorator which checks for this query
            parameter.</p>
        <pre><code class="python">
from flask import Response
from server.security import jwt_required_in_query

@blueprint.route('/actionstream', methods=['GET'])
@jwt_required_in_query
def stream_workflow_action_events():
    return action_result_stream.stream()
        </code></pre>

        <h4>5. Use the endpoint in an interface</h4>
        <p>
            Now that we have an endpoint created, it's time to use it in our interface to display the real-time data.
            In our index.html body, append the following HTML:
        </p>
        <pre><code class="html">
&lth1&gtAction Results&lt/h1&gt
&lttable id="actionResults"&gt
    &ltthead&gt
        &lttr&gt
            &lttd&gtAction ID&lt/td&gt
            &lttd&gtAction Name&lt/td&gt
            &lttd&gtTimestamp&lt/td&gt
            &lttd&gtStatus&lt/td&gt
        &lt/tr&gt
    &lt/thead&gt
    &lttbody&gt&lt/tbody&gt
&lt/table&gt
        </code></pre>
        
        <p>
            This creates a simple table for us to put the action results once we receive them. Note the tbody is empty.
            In our main.js, the following JavaScript code will initiate the SSE event handling to add new rows to our table.
            This should be placed below the other JS code but before the end of the module.
        </p>

        <pre><code class="javascript js">
const eventSource = new EventSource('interfaces/HelloWorld/actionstream?access_token=' + sessionStorage.getItem('access_token'));

function eventHandler(message) {
    let result = JSON.parse(message.data);
    
    $('#actionResults tbody').append(`
        &lttr&gt
            &lttd&gt${result.sender_id}&lt/td&gt
            &lttd&gt${result.sender_name}&lt/td&gt
            &lttd&gt${result.timestamp}&lt/td&gt
            &lttd&gt${result.data.status}&lt/td&gt
        &lt/tr&gt
    `);
}

eventSource.addEventListener('action_success', eventHandler);
eventSource.addEventListener('action_error', eventHandler);
eventSource.addEventListener('error', (err) => {
    console.error(err);
});
        </code></pre>

        <p>
            We see here that we have an event handler function that is bound to both action success and error events,
            meaning that they are processed the same. Using the SSE you can produce many different types of events
            and potentially process them in different manners. This code will simply push a new row onto the actionResults
            table which contains some of the information from the action result received from the SSE.
        </p>

        <h4>More options for SSE streams</h4>
        <p> SSE streams can be used without registering a callback by using the stream's <code>publish</code> method. For
            example, the following code would push the current time to the event "heartbeat"</p>
        <pre><code>
action_result_stream.publish(str(datetime.utcnow()), event='heartbeat')
        </code></pre>
        <p> SSE streams can add additional headers to their response using the "headers" option on the <code>stream()</code>
            method. The default headers are "Cache-Control: no-cache" and "Connection: keep-alive". The following code
            would add a custom "X-My-Header" header to the response. </p>
        <pre><code>
@blueprint.route('/actionstream', methods=['GET'])
@jwt_required_in_query
def stream_workflow_action_events():
    return action_result_stream.stream(headers={'X-My-Header': 'some-value'})
        </code></pre>

    </div>
  </div>
</div>

<div class="w3-container w3-black w3-center w3-opacity w3-padding-64">
    <h1 class="w3-margin w3-xlarge">Questions? Comments? </h1>
    <h1 class="w3-margin w3-xlarge"> Reach out to us at <a href="mailto:walkoff@nsa.gov"> walkoff@nsa.gov </a> </h1>
</div>

<!-- Footer -->
<footer class="w3-container w3-padding-64 w3-center w3-opacity">
 <!-- <p>Powered by <a href="https://www.w3schools.com/w3css/default.asp" target="_blank"> </a></p> -->
</footer>

<script src="../../files/plugins/jQuery/jQuery-2.1.4.min.js"></script>
<script>
// Used to toggle the menu on small screens when clicking on the menu button
function myFunction() {
    var x = document.getElementById("navDemo");
    if (x.className.indexOf("w3-show") == -1) {
        x.className += " w3-show";
    } else {
        x.className = x.className.replace(" w3-show", "");
    }
}
</script>
</body>
</html>
